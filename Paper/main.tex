\section{Algorithmus} % High-level description
\todo[inline]{Textuelle Beschreibung, Grafiken}
% Idee für Layout: 
% - Gruppenelemente in Blase passen
% - festes Layout pro Hierarchiestufe berechnen
% - Layouts in Gruppen richten sich nach Ports aus Layout von Stufe darüber
% - Layouts niedrigerer Stufe beeinflussen Layouts höherer Stufe nur durch benötigten Platz
	% Stichwort: uniform scaling
	
		% bottom-up und top-down
	% (Layoutalgorithmus hierbei egtl frei wählbar, kräftebasiert aber besser in Hinsicht auf Verhalten Algorithmus mit Ankern)
	% bottom-up
		% Berechne Layouts pro Gruppe auf niederigster Stufe
		% versuche hierbei Fläche klein zu halten bzw Elemente in Kreis zu zwingen
		% Berechne die approximierte resultierende benötigte Fläche für Gruppe
	
		% Benutze appr. benötigte Fläche für Wiederholung des Schritts auf Stufe höher (bis auf letzte)

	% top-down
		% (hier noch zu entscheiden ob mit Gruppen offen oder zu)
			% (für Variante zu: schliese alle Gruppen und berechne approximierte, logarithmisch abgeschwächte Abstoßungsfaktor anhand von benötigter Größe)
		% berechne Layout auf oberster Stufe
		% Lege Ports für Gruppen auf oberster Stufe fest
		
		% berechne iterativ absteigend Layouts in Gruppen mit festgelegten Ports

\begin{algorithm}[H]
\label{Layoutalgorithmus}
\SetAlgoLined
\Ein{Graph $G=(V,E)$ mit Gruppen $S$ } % mit Koten $V$ mit Größe, gerichteten \& gefärbten Kanten $E$, Mengen $S$ von Knoten und Elementen aus $S$
\Aus{Gruppen-hierarchisches Layout von $G$ } % mit diesen und jenen Eigenschaften, evtl Name einführen für Referenzierung
$i = $ höchste Stufe einer Gruppe \;
\Solange{$i \geq 0$}{ % benötigt, dass oberste Ebene auch Gruppe
  \Fuer{Jede Gruppe $S$ auf Stufe $i$} {
	berechnete Layout der Gruppe $S$\;
	berechne benötigte Fläche des Gruppenlayouts\;	
  }
  $i= i - 1$\;
}
Lege Ports für Gruppen auf Stufe 1 fest\;
$i = 1$\;
\Solange{$i \leq$ Anzahl Stufen}{ % benötigt, dass oberste Ebene auch Gruppe
  \Fuer{Jede Gruppe $S$ auf Stufe $i$} {
	berechnete Layout der Gruppe $S$ unter Berücksichtigung der Ports\;
	Lege Ports für Gruppen auf Stufe $i+1$ fest;
  }
  $i= i + 1$\;
}

\caption{Layoutalgorithmus}
\end{algorithm}

% DEFINITION Anker
% Pseudoknoten, wird nicht gerendert
% hat Kanten zu allen Knoten, welche er Ankert
% optimale Kantenlänge = 0
% Federkraft Fallabhängig und jeweils zu spezifizieren

\subsection{Layout in Gruppen in Abhängigkeit von Ports}
% Problem: Layout eines Graphens (mit Labelknoten) innerhalb eines Kreises mit Ports für ausgehende kanten
% Äquivalent: Layout eines Graphens mit punktförmigen Knoten auf Kreis und gelabelten Knoten innerhalb des Kreises
\todo[inline]{Problemreduktion beschreiben, Lösungsvorschlag}

% was betrachten?
In diesem Abschnitt betrachten wir Zeile 13 des Layoutalgorithmus \ref{Layoutalgorithmus} genauer. 
% was ist ziel?
Hier ist das Ziel ein Layout für eine Gruppe mit bereits gegebenen Ports, also mit gegebenen Winkel für Kanten zur Gruppe, zu finden.
Das heißt, wir suchen nun einen Layout für den durch die Gruppe induzierten Teilgraphen sowie aus der Gruppe herausgehende Kanten.
Dieses soll, wie oben beschrieben, ein Layout innerhalb eines Kreises sein und die Gruppengrenze-überschreitenden Kanten zu den festgelegten Ports führen.
% was ist schwierig?
Eine der Herausforderung hierbei ist, eine geeignete Größe für den Kreis um die Gruppe zu finden. Auch zum finden dieses Layouts benutzen wir wieder einen kräftebasierten Algorithmus.

% Bemerkung: Layout in einer Gruppe ist von Layouts in anderen Stufen und Gruppen unabhängig (außer durch Ports)

		%// Genau zu spezifizieren:
		%// - wie wird es modelliert: Ports als feste Knoten? nur Reihenfolge festlegen und flexibel auf gewissem Radius? ..
		%// Ports bleiben fest. Argument: Sowieso Winkel an Ports, nich wesentliche Winkel-Änderung erwartet bei Veränderung
% was ist gegeben?
% wie betrachten wir es? wie ist es modeliert?
Gegeben sei nun also eine Gruppe $H$. Vom Layouts der nächsthöheren Stufe wurden bereits die Ports der Gruppe festgelegt, d.h. wir haben die Winkel an denen Gruppengrenze-überschreitenden Kanten den Kreis schneiden sollen. Diese Ports modellieren wir als feste Knoten auf dem Kreis der Gruppe an ihren jeweiligen Winkeln.
Des weiteren haben wir bereits ein Layout $\mathcal{L_H}$ der Gruppe $H$ ohne Gruppengrenze-überschreitenden Kanten in Zeile 4 des Layoutalgorithmus \ref{Layoutalgorithmus}  berechnet.
Aus Zeile 5 haben wir daher auch eine erste Größe für den Kreis der Gruppe, welche durch den Radius beschreiben und durch $R'_H$ gegeben sei. 
% was sind die essentiellen punkte?
	% anfangslayout, anfangsradius, neuer radius, 
Der grobe Ablauf des Algorithmus ist in Algorithmus \ref{Gruppenlayoutalgorithmus} beschrieben. Die essentiellen Schritte sind also die Wahl eines Anfangslayouts (Zeile 1), Finden eines optimalen Radius (2) und das Berechnen eines Layouts (3).

\begin{algorithm}[H]
\label{Gruppenlayoutalgorithmus}
\SetAlgoLined
\Ein{Gruppe $H$, sowie Ports und Kanten zu Ports} 
\Aus{Gruppenlayout $\L_H$ von $H$ }
Wähle Anfangslayout\;
Finde Radius $R$ für Kreis\;
Berechne Gruppenlayout  $\L_H$ mit kräftebasiertem Algorithmus\;
\caption{Gruppenlayoutalgorithmus}
\end{algorithm}



Die Wahl eines Anfangslayouts und das finden eines optimalen Radius beschrieben wir  in den folgenen Abschnitten  genauer. 
% - Anziehung zu Mittelpunkt
	% ja, mit Kanter
	% schwache Feder mit Faktor $\alpha$
Für die Berechnung eines Gruppenlayouts verweisen wir wieder lediglich auf die oben genannten kräftebasierten Algorithmen, welche mit Knoten von bestimmter Größer umgehen können. 
Jedoch schlagen wir auch hier wieder das hinzunehmen eines Ankers vor, welcher alle Elemente zur Mitte des Kreises ziehen soll. Dies soll auch verhindern, dass eventuell nicht zusammenhängde Komponenten der Gruppe auseinander driften. Die Kraft dieses Ankers sei mit dem Faktor $\alpha$ beschrieben. 

% - Anfangslayout: 
\subsubsection{Anfangslayout}
Für die Wahl eines Anfangslayouts, Zeile 1 in Algorithmus \ref{Gruppenlayoutalgorithmus} schlagen wir folgenden Ansatz vor.
	% c) Layout von Größenberechnung spiegeln (nicht, vertikal, horizontal, beides) und Längen der Port-Knoten-Kanten summieren
In Zeile 4 von Algorithmus \ref{Layoutalgorithmus} wurde für $H$ bereits ein Layout $\L'_H$ berechnet. Dieses lässt sich sowohl horizontal als auch vertikal spiegeln, ohne die Ausrichtung der einzelnen Knoten, welche ja nach den Achsen ausgerichtete Rechtecke sind, verändert wird. Das heißt wir haben vier verschiedene Layouts, nämlich orginal, vertikal oder horizontal gespiegelt sowie vertikal und horizontal gespiegelt. Um möglichst lange Kanten von Knoten zu Ports durch die ganze Gruppe zu vermeiden, wählt man nun jenes Layout, bei dem die Summe der Kantenlängen dieser Kanten am kleinsten ist.  Sei $\mathcal{L}'_H$ nun das gewählte Anfangslayout.

\todo[inline]{Grafik Anfangslayout}

Natürlich gibt es auch noch weitere Ansätze zum finden eines Anfangslayouts.
		% b) random
Einfache Ansätze wären zum Beispiel eine zufällige Platzierung der Knoten oder die Platzierung aller Knoten in die Mitte des Kreises, um dann den Rest dem kräftebasierten Layoutalgorithmus zu überlassen. Man könnte sich jedoch auch einen anspruchsvolleren Ansatz überlegen, bei dem man das Gruppenlayout ausgehend von den Ports konstruiert.
	% a) Knoten mit aus Gruppe ausgehende eingehende Kanten direkt neben Ports positionieren, dann breitensuche oder so weiter


% - Größe des Kreises definiert durch Radius R
\subsubsection{Bestimmen des Kreisradius}
Für die Berechnung eines angemessenen Kreisradius schlagen wir einen iterativen Algorithmus vor. Dessen Idee ist es, für einen gegeben Radius ein Layout zu berechnen und dann zu testen, ob der Radius verkleiner werden kann. Ist dies der Fall, so wiederhole das Vorgehen. Ansonsten erhöhe entweder den Faktor $\alpha$ für die Kraft des Ankers zum Mittelpunkt oder breche ab.
Als Anfangsradius kann der Radius $R'_H$ aus Algorithmus \ref{Layoutalgorithmus} Zeile 5 mal einem Faktor $\beta \geq 1$ verwendet werden.
Algorithmus \ref{Kreisradiusalgorithmus} spezifiziert also Zeile 2 von Algorithmus  \ref{Gruppenlayoutalgorithmus} und setzt auch dessen Zeile 3 um.

\begin{algorithm}[H]
\label{Kreisradiusalgorithmus}
\SetAlgoLined
\Ein{Gruppe $H$, Ports, Kanten zu Ports, Anfangslayout $\L'_H$, Radius $R'_H$}
\Aus{Gruppenlayout $\L_H$ von $H$, Radius $R_H$}
$R = \beta \cdot R'_H = $ Anfangsradius für Kreis\;
$\L_H = \L'_H \cup$ Ports $\cup$  Kanten zu Ports\;
Führe kräftebasiertem Algorithmus auf  $L_H$ aus\;
\eWenn{$R$ verkleinert werden kann}{
	Passe $R$ an\;
}{
	\eWenn{$\alpha$ nicht zu groß}{
		erhöhe $\alpha$\;
		gehe zu 3\;
	}{
		Algorithmus fertig\;
	}
}
\caption{Kreisradiusalgorithmus}
\end{algorithm}

Für Algorithmus \ref{Gruppenlayoutalgorithmus} muss natürlich noch spezifiziert werden, was es heißt, dass der Radius in Zeile 4 verkleinert werden kann oder dass $\alpha$ nicht zu groß ist. Das der Radius $R$ verkleinert werden kann, soll bedeuten, dass bei kleinerem $R$ aber gleichem Layout der Kreis keine Knoten schneidet. Typisch für Parameter bei kräftebasierten Algorithmen, wird um eine geeignte maximale Größe von $\alpha$ zu finden, wohl eine Implementierung und verschiedene Tests benötigt. Das selbe gilt für $\beta$ um einen geeigeneten Anfangsradius zu finden.
	% Gegeben: Berechnete Größe R' in bottom-up Verfahren
	% Problem: berechnete Größe ohne Ports, kann zu klein sein, da Platz für Kanten zu Ports geschaffen werden muss (darf nicht durch Knoten)
	% Ziel: finde Faktor $\beta$ sodass $R = \beta * R'$ groß genug            ( es gillt immer $R \geq R'$)
	
	% Variante induvidualisiertes $\beta$ für jede Gruppe - anfangs 1. Startlayout  und später 2. für jeden Zustand 
	  %________________________________________________________________________________________________________________%
	 	% Algorithmus zum finden von $\beta$
			% Idee: berechne Layout, teste ob Radius verkleinert werden kann, erhöhe bei bedarf Anziehung zu Mitte ($\alpha$)
			% Abbruchbedingungen: - Änderung in Größe nach erhöhen von Anziehung zu Mitte zu klein
			%			         - Anziehung zu Mitte wurde schon stark erhöht und man ist schon nahe an R' 
	 %_________________________________________________________________________________________________________________%		



Eine weitere Variante zur Berechnung des Kreisradius könnte durch erwartete Größe von Gruppen umgesetzt werden.
	% Variante festes $\beta$ und mittels Berechnung von erwarteten Größen
	%_________________________________________________________________________________________________________________%
		% Idee: Berechne ausreichende Größe anhand von Größen der Kinder
		
		% Für Kindruppe $G_i$ ist $x_i = ((Radius in Zustand von G_i) - (max Radius von G_i) ) \cdot \xi$, wobei $0 < \xi < 1$
		% $R = R' + x_i  + \delta$
	%_________________________________________________________________________________________________________________%
							

	% Anmerkung: Da in Praxis (Argumentkarten) die Gruppentiefe nicht hoch ist und in Gruppe nicht viele Gruppen sind, 
			% können hier auch die Größen für alle Fälle berechnet werden

% Postprocessing: Kantenklätung

\subsection{Layout-Anpassung beim Öffnen oder Schließen einer Gruppe}
% Removing node intersections when changing the size of a node while keeping the mental map
% Problemabstraktion: Auflösen von Knotenlabelüberschneidung nach Größenveränderung eines Knotenlabes unter Beibehaltung der mentalen Karte
\todo[inline]{Problemreduktion beschreiben, Lösungsvorschlag}

% Idee für Verhalten: Anker
% was passiert, wenn Gruppe geöffnet oder geschlossen wird?
% - jedes Element auf oberster Ebene bekommt festen aber schwachen Anker an Startposition von Anfangslayout um immer dazu ähnlich zu bleiben
% - jedes Element auf gleicher Ebene wie veränderte Gruppe bekommt einen Anker an aktueller Position
	% geöffnete Gruppe stoßt alle Elemente ab, sodass sie genug Platz hat.  Rest auch kräftebasiert um Ähnlichkeit zu Layout davor zu bewahren
	% geschlossene Gruppe stoßt nun Elemente weniger ab. Rest wieder kräftebasiert um Ähnlichkeit zu Layout davor zu bewahren
% - Ist geänderte Gruppe nicht auf oberster Ebene, so wiederholt sich der Prozess iterativ nach oben, da übergeordnete Gruppen auch mehr Platz brauen oder freigeben

% Genau zu spezifizieren:
% - Wann werden Anker gesetzt, wie lange bestehen sie
	% Grundanker, Stärke muss man testen, evtl so stark wie eine Kante $\cdot \gamma$ mit $\gamma \in [1, irgendwas]$
	% Abhängig von Kräftealgorithmus, wenn dort Masse von Gruppen nicht mit einbezogen wird, dann für größere Gruppen, stärkere Anker
	% ((( Erweiterungsmöglichkeit: Anker von jedem Schritt speichern, jedoch pro Schritt abschwächen)))
% - Verhältnis Gruppengrößen und Kräfte für Abstoßungen/Anziehungen
	% Variante zu entscheiden: a) Größe proportional, dann linear/logarithmisch
	%				  b) Abstoßung proportional, dann logarithmisch
% - Verhalten von Ports bei Layoutänderung
	% bleiben fest. keine großen Änderungen zu erwarten.

% Bei zu starker Veränderung also zu viel Kraft auf Ankern: verwerfe Grundanker und setze für diese Runde neue
% evtl ebenso für Ports, wenn Knick zu groß


% ------- Vorgehen für Parameterwahl vorschlagen
